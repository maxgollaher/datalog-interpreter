#ifndef LAB02_PARSER_H
#define LAB02_PARSER_H

#include <vector>
#include "Token.h"
#include "DatalogProgram.h"
#include <stdexcept>
#include "Interpreter.h"

class Parser {
private:
    vector<Token> tokens; // vector object containing a list of tokens generated by the Scanner class

public:
    explicit Parser(const vector<Token> &tokens) : tokens(tokens) {}

    [[nodiscard]] TokenType tokenType() const { return tokens.at(0).getType(); }

    [[nodiscard]] string tokenValue() const { return tokens.at(0).getValue(); }

    [[nodiscard]] int tokenLine() const { return tokens.at(0).getLine(); }

    void advanceToken() { tokens.erase(tokens.begin()); }

    void match(TokenType t) {
        if (tokenType() == t) {
            advanceToken();
        } else {
            throw runtime_error("Failure!");
        }
    }

    /** A method to run the datalogProgram for project 2:
     * First creates a DatalogProgram object and parses through the tokens generated
     * by the Scanner class. As it parses the data, it creates Predicate objects and
     * Rule objects to add to the DatalogProgram vectors.
     *
     * If it is successful, the program outputs the toString of the DatalogProgram
     * @throw runtime_error: If there is an error encountered, the program throws an error and aborts.
     * */
    void datalogProgram() {
        try {
            DatalogProgram datalogProgram = DatalogProgram();

            match(SCHEMES);
            match(COLON);
            Predicate schemePred = scheme();
            datalogProgram.addSchemes(schemePred);
            schemeList(datalogProgram);
            if (datalogProgram.noSchemes()) { // DatalogProgram must have schemes
                throw runtime_error("Failure!");
            }

            // Facts and Rules are optional, "Facts:" and "Rules:" however, is not
            match(FACTS);
            match(COLON);
            factList(datalogProgram);
            match(RULES);
            match(COLON);
            ruleList(datalogProgram);

            match(QUERIES);
            match(COLON);
            Predicate queryPred = query();
            datalogProgram.addQueries(queryPred);
            queryList(datalogProgram);
            if (datalogProgram.noQueries()) { // DatalogProgram must have queries
                throw runtime_error("Failure!");
            }

            match(END);

            Interpreter interpreter(datalogProgram);
        } catch (const exception &error) {
            cout << error.what() << endl << "  " << tokens.at(0).toString() << endl;
        }
    }

    /** This recursive function parses through the tokens provided by the Scanner and adds parameter
     * objects to a Predicate object.
     * @param pred: A predicate object that parameters will be added to*/
    void idList(Predicate &pred) {
        if (tokenType() == COMMA) {
            match(COMMA);
            string value = tokenValue();
            TokenType type = tokenType();
            Parameter param = Parameter(value, type);
            pred.add(param);
            match(ID);
            idList(pred);
        } else {
            // lambda
        }
    }

    /** This recursive parses through the tokens provided by the Scanner and adds parameter
   * objects to a Predicate object.
   * @param pred: A predicate object that parameters will be added to*/
    void stringList(Predicate &pred) {
        if (tokenType() == COMMA) {
            match(COMMA);
            string value = tokenValue();
            TokenType type = tokenType();
            Parameter param = Parameter(value, type);
            pred.add(param);
            match(STRING);
            stringList(pred);
        } else {
            // lambda
        }
    }

    /**This function creates a scheme object in the form of a predicate object that
     * satisfies the grammar:
     * scheme -> ID LEFT_PAREN ID idList RIGHT_PAREN
     * @return Predicate: a Predicate object in the form ID(ID,ID....)
     * @throw runtime_error: throws a runtime_error when the function is called and a
     * scheme object is NOT found */
    Predicate scheme() {
        if (tokenType() == ID) {
            string name = tokenValue();
            Predicate pred = Predicate(name);
            match(ID);
            match(LEFT_PAREN);
            string value = tokenValue();
            TokenType type = tokenType();
            Parameter param = Parameter(value, type);
            pred.add(param);
            match(ID);
            idList(pred);
            match(RIGHT_PAREN);
            return pred;
        }
        throw runtime_error("Failure!");
    }

    /**Recursive function that modifies a DatalogProgram object by creating scheme Predicates
     * to add to the schemeList vector
     * @param datalogProgram: the DatalogProgram object to be modified */
    void schemeList(DatalogProgram &datalogProgram) {
        if (tokenType() == ID) {
            Predicate sch = scheme();
            datalogProgram.addSchemes(sch);
            schemeList(datalogProgram);
        } else {
            // lambda
        }
    }

    /**This function creates a fact object in the form of a predicate object that
   * satisfies the grammar:
   * fact -> ID LEFT_PAREN STRING stringList RIGHT_PAREN PERIOD
   * @return pred: a Predicate object in the form ID(STRING,STRING....).
   * @throw runtime_error: throws a runtime_error when the function is called and a
   * fact object is NOT found */
    Predicate fact() {
        if (tokenType() == ID) {
            string name = tokenValue();
            Predicate pred = Predicate(name);
            match(ID);
            match(LEFT_PAREN);
            string value = tokenValue();
            TokenType type = tokenType();
            Parameter param = Parameter(value, type);
            pred.add(param);
            match(STRING);
            stringList(pred);
            match(RIGHT_PAREN);
            match(PERIOD);
            return pred;
        }
        throw runtime_error("Failure!");
    }

    /**Recursive function that modifies a DatalogProgram object by creating fact Predicates
    * to add to the factList vector
    * @param datalogProgram: the DatalogProgram object to be modified */
    void factList(DatalogProgram &datalogProgram) {
        if (tokenType() == ID) {
            Predicate factPred = fact();
            datalogProgram.addFacts(factPred);
            factList(datalogProgram);
        } else {
            // lamda
        }
    }

    /**Creates a Predicate object that satisfies the grammar:
     * headPredicate ->	ID LEFT_PAREN ID idList RIGHT_PAREN
     * @return headPred: the Predicate object*/
    Predicate headPredicate() {
        string name = tokenValue();
        Predicate headPred = Predicate(name);
        match(ID);
        match(LEFT_PAREN);
        string value = tokenValue();
        TokenType type = tokenType();
        Parameter param = Parameter(value, type);
        headPred.add(param);
        match(ID);
        idList(headPred);
        match(RIGHT_PAREN);
        return headPred;
    }

    void parameter() {
        if (tokenType() == STRING) {
            match(STRING);
        } else {
            match(ID);
        }
    }

    /** This recursive function parses through the tokens provided by the Scanner and adds parameter
     * objects to a Predicate object.
     * @param pred: A predicate object that parameters will be added to */
    void parameterList(Predicate &pred) {
        if (tokenType() == COMMA) {
            match(COMMA);
            string value = tokenValue();
            TokenType type = tokenType();
            Parameter param = Parameter(value, type);
            pred.add(param);
            parameter();
            parameterList(pred);
        } else {
            // lambda
        }
    }

    /**Creates a Predicate object that satisfies the grammar:
     * predicate ->	ID LEFT_PAREN parameter parameterList RIGHT_PAREN
     * @return pred: the Predicate object */
    Predicate predicate() {
        string name = tokenValue();
        Predicate pred = Predicate(name);
        match(ID);
        match(LEFT_PAREN);
        string value = tokenValue();
        TokenType type = tokenType();
        Parameter param = Parameter(value, type);
        pred.add(param);
        parameter();
        parameterList(pred);
        match(RIGHT_PAREN);
        return pred;
    }

    /**Recursive function that parses the tokens generated by the Scanner to add to
     * a Predicate vector.
    * @param paramVector: the vector object to be modified */
    void predicateList(vector<Predicate> &paramVector) {
        if (tokenType() == COMMA) {
            match(COMMA);
            Predicate pred = predicate();
            paramVector.push_back(pred);
            predicateList(paramVector);
        } else {
            // lambda
        }
    }

    /**Creates a Rule object using the tokens generated by the Scanner in the form:
     * rule ->	headPredicate COLON_DASH predicate predicateList PERIOD
     * @return Rule: a rule object consisting of a headPredicate and a vector of Predicates */
    Rule rule() {
        Predicate headPred = headPredicate();
        match(COLON_DASH);
        vector<Predicate> paramVector;
        Predicate pred = predicate();
        paramVector.push_back(pred);
        predicateList(paramVector);
        match(PERIOD);
        return {headPred, paramVector};
    }

    /**Recursive function that modifies a DatalogProgram object by creating Rule objects
     * to add to the ruleList vector
     * @param datalogProgram: the DatalogProgram object to be modified */
    void ruleList(DatalogProgram &datalogProgram) {
        if (tokenType() == ID) {
            Rule rulePred = rule();
            datalogProgram.addRules(rulePred);
            ruleList(datalogProgram);
        } else {
            // lambda
        }
    }

    /** @return pred: a predicate object to satisfy the grammar for a query
     * query -> predicate Q_MARK */
    Predicate query() {
        Predicate pred = predicate();
        match(Q_MARK);
        return pred;
    }

    /**Recursive function that modifies a DatalogProgram object by creating query Predicate objects
    * to add to the ruleList vector
    * @param datalogProgram: the DatalogProgram object to be modified */
    void queryList(DatalogProgram &datalogProgram) {
        if (tokenType() == ID) {
            Predicate queryPred = query();
            datalogProgram.addQueries(queryPred);
            queryList(datalogProgram);
        } else {
            // lambda
        }
    }


};

#endif //LAB02_PARSER_H
